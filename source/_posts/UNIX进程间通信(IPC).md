---
title: UNIX进程间通信(IPC)
date: 2020-07-27 00:40:00
tags: [进程间通信,操作系统]
categories: 编程
toc: true
---

<img src="https://s1.ax1x.com/2020/08/11/aq5VnP.jpg" alt="IPC" style="zoom: 40%;" />

进程间通信(IPC)，顾名思义，就是实现两个或多个进程间通信进行交流的一种机制。这种通信交流的目的一般是为了进行数据传输、通知事件或者进程间资源共享等等。本文首先对IPC的发展历程进行一个简短的介绍，有助于我们理解为什么会有这些进程间通信机制，主体内容对常用的几种IPC机制进行展开叙述。文章部分内容参考了APUE和网上的一些博客，融入了个人的一些见解。
<!--more-->

#### 进程间通信 
由于操作系统使用了虚拟内存，对于所有进程来说，它们只能看到操作系统想让他们看到的虚拟地址空间，这块空间是每个进程的私有财产，这部分私有财产是收到操作系统保护的，如果尝试访问不属于自身的地址空间，则会直接导致程序崩溃。因此，无论出于什么目的，想要访问一块不属于进程自身的地址空间时，就需要使用到进程间通信了。

#### 进程间通信的发展历史

Linux下的进程通信手段基本上是从Unix平台上的进程通信手段继承而来的。而对Unix发展做出重大贡献的两大主力AT&T的贝尔实验室及BSD（加州大学伯克利分校的伯克利软件发布中心），在进程间通信方面的侧重点有所不同。前者对Unix早期的进程间通信手段进行了系统的改进和扩充，形成了“System V IPC”，通信进程局限在单个计算机内；后者则跳过了该限制，形成了基于套接口（socket）的进程间通信机制。Linux则把两者均继承了下来。

<img src="https://s1.ax1x.com/2020/07/31/a1waJ1.jpg" alt="Linux IPC" style="zoom: 33%;" />

最初Unix IPC包括：管道(PIPE)、FIFO、信号(signal)；

System V IPC包括：System V 消息队列、System V 信号量、System V 共享内存；

POSIXIPC包括： POSIX消息队列、POSIX信号量、POSIX共享内存。

需要指出的是：POSIX是Portable Operating System Interface（可移植操作系统接口）的缩写。POSIX 是由 IEEE 制定的一系列标准，以阐明和统一应用程序编程接口；如果你使用了某些POSIX并未进行标准化的API时，在将该程序或者库移植到其他的类UNIX系统中时，会遇到很大的麻烦。同时，Socket虽然常用于网络通信，但他同时也可以用于本机内的不同进程间的通信(Unix domain socket)。

本文以下的介绍基于**POSIX标准**。

#### 1、管道(PIPE)

管道是一种较为古老的进程间通信方式，我们一般所说的PIPE属于```匿名管道```，而后面将要说到的FIFO则是```命名管道```。管道的实际上是一个由**内核管理的缓冲区**，也可理解为一个文件(就像Linux中的任意一个普通文件一样)，我们可以对这块缓冲或者说文件进行写入和读取的操作，与操作文件的方式类似。

管道是一个单向通信的方式，也就是说先写输入管道的信息，一定会先被读取出来，即所谓的“先入先出”。同时，管道(这里指的是匿名管道，PIPE)只能够实现父子进程或是兄弟进程间的通信，无任何血缘关系的进程间无法通过PIPE来实现通信。

当我们在进程中创建一个PIPE之后，会在内存当中开辟出一块缓冲区，并且为进程返回两个文件描述符：`fd[0]`与`fd[1]`。其中，`fd[0]`连接了管道的读取端，而`fd[1]`连接了管道的写入端。我们向`fd[1]`里写入的数据可以从`fd[0]`中读取出来。当父进程调用`fork`创建出一个子后，子进程中的`fd[0]`与`fd[1]`同样指向内存中的这一块缓冲区，注意，父进程与 子进程的fd指向的是同一块内存。因此，如果需要实现父进程向子进程的通信，只需关闭父进程的读取端口，关闭子进程的写入端口即可。反之亦然。

当**管道的一端被关闭**之后，会出现以下两种情况：

1. 当去```读```一个```写```端被关闭的pipe时，在内核中的管道缓冲区内的数据全部被读取完之后，read函数会返回0，表示文件结束。虽然可以通过fork让多个进程对一个管道具有写打开文件描述符，但是一般只有一个读进程与一个写进程。这与FIFO不同。
2. 当```写```一个```读```端被关闭的pipe时，会产生`SIGPIPE`信号。这个信号可以被signal函数捕获，如果不对该信号进行捕获，则会产生错误，`write()`返回-1，errno为SIGPIPE。

`PIPE_BUF`规定了内核的pipe缓冲区大小。通过`pathconf()`或`fpathconf()`可以确定PIPE_BUF的大小。

函数`popen`实现了`创建一个管道`->`fork一个子进程`->`关闭未使用的管道端口`->`执行一个shell命令`->`等待命令终止`的操作。它的函数原型为：

```c++
FILE *popen(const char *cmdstring, const char *type);
```

cmdstring为需要执行的shell命令，而type是“r”，则返回的文件指针是可读的，“w”返回的文件指针是可写的。

还有一个函数`pclose()`，可以用于关闭标准I/O流，等待命令的终止，返回shell的终止状态。它的函数原型是：

```C++
int pclose(FILE *fp);
```

#### 2、命名管道(FIFO)                                  

之前已经介绍过了FIFO，如果说PIPE是匿名管道，那么FIFO就是命名管道。

FIFO相比于PIPE而言的最大的优点就是，它可以用于非父子进程间的通信。之所以叫FIFO，是因为**管道本质上是一个先进先出的队列数据结构**，最早放入的数据被最先读出来，从而保证信息交流的顺序。

创建一个FIFO类似于创建一个文件，需要给出文件路径名，而FIFO的路径名也会实实在在的存在于文件系统当中。因此，即使某些进程与创建了FIFO的进程并不具有血缘关系，但是只要它们对这个路径具有访问的权限，就能够通过FIFO与之进行通信。

FIFO包含下面两个特性：

* 和PIPE一样，FIFO仅提供**半双工**的数据通信，即只支持**单向的数据流**。
* 和PIPE不同的是，FIFO可以支持**任意**两个进程间的通信。

FIFO的创建需要使用函数：
```C++
int mkfifo( const char* path, mode_t mode );
```

其中的path为fifo文件的路径，mode为参数宏，共有三个宏可供选择，分别为为"O_RDONLY"、"O_WRONLY"、和"O_NONBLOCK"，其中，只读和只写可以作为独立参数，而非阻塞模式只能跟随在只读与只写后面。共可以组成四种模式：

1. "O_RDONLY"：以只读的方式打开一个管道文件，同时进程将会阻塞，直到有另一个进程以只写的方式打开这个管道文件。
2. "O_RDONLY | O_NONBLOCK"：以只读的方式打开一个管道文件，但是进程不会阻塞。
3. "O_WRONLY"：以只写的方式打开一个管道文件，同时进程将会阻塞，直到有另一个进程以只读的方式打开这个管道文件。
4. "O_WRONLY | O_NONBLOCK"：以只写的方式打开一个管道文件，但是进程不会阻塞。

通过`mkfifo()`创建了FIFO文件之后，可以通过`read()`与`write()`函数对该文件做读写操作，操作方式与对普通文件进行操作的方式一致。

类似于管道，当去读一个写端被关闭的FIFO时，在内核中的管道缓冲区内的数据全部被读取完之后，`read`函数会返回0，表示文件结束。当写一个读端被关闭的FIFO时，会产生`SIGPIPE`信号。

FIFO主要具有以下两种用途：

- 由**shell命令**使用，以便将数据从一条管道线传送到另一条，为此无需创建中间临时文件。
- 用于**客户进程-服务器进程**应用程序中，以在客户进程和服务器进程之间传递数据。

#### 3、消息队列(MessageQueue)

##### **XSI IPC**

在学习消息队列之前，首先要介绍一个概念——**XSI IPC**。XSI IPC源自于1970年的一种称为“Columbus UNIX”的AT&T内部版本，后来被添加至System V上。XSI IPC包含了三种进程间通信的方式，分别为：**消息队列**、**信号量**、**共享内存**。每种IPC都有特定的**生产者**、**所有者**和**访问权限**。它们之间有很多相似之处，我们首先学习一下它们相似的一些特征：

**①、标识符(identifier)和关键字(key)**

每个内核中的IPC结构（消息队列、信号量或共享内存）都用一个**非负整数**的**标识符**(identifier)加以引用。无论何时创建IPC结构（调用`msgget()`、`semget()`或`shmget()`）,都应指定一个关键字（key），关键字的数据类型由系统规定为key_t，通常在头文件`<sys/types.h>`中被规定为长整型。关键字key方便多个合作进程能够在同一个IPC对象上汇聚，而key则是这样一个外部命名的方案。关键字由内核变换成标识符。

**②、权限结构**

XSI IPC为每一个IPC结构设置了一个ipc_perm结构。该结构规定了权限和所有者。它至少包括下列成员：

```C
struct ipc_perm {
    uid_t    uid;     /* owner's effective user id */
    gid_t    gid;     /* owner's effective group id */
    uid_t    cuid;    /* creator's effective user id */
    gid_t    cgid;    /* creator's effective group id */
    mode_t   mode;    /* access modes */
    ...
};
```

在创建IPC结构时，对所有字段都赋初值。以后，**可以调用`msgctl`、`semctl`或`shmctl`修改`uid`、`gid`和`mode`字段**。为了改变这些值，调用进程必须是IPC结构的创建者或超级用户。更改这些字段类似于对文件调用`chown`和`chmod`。

**③、结构限制**

三种形式的XSI IPC都有内置限制（built-in limit）。这些限制的大多数可以通过重新配置内核而加以更改。在报告和修改限制方面，每种平台都提供它自己的方法。Linux 2.4.22和Mac OS X 10.3提供了`sysctl`命令，用该命令观察和修改内核配置参数。

**④、优点和缺点**

**XSI IPC的主要问题是：IPC结构是在系统范围内起作用的，没有访问计数。**例如，如果进程创建了一个消息队列，在该队列中放入了几条消息，然后终止，但是消息队列及其内容并不会被删除。

**XSI IPC的另一个问题是：这些IPC结构在文件系统中没有名字。**我们不能用文件I/O和文件和目录章节中所述的函数来访问它们或修改它们的特性。为了支持它们不得不增加了十几条全新的系统调用（`msgget`、`semop`、`shmat`等）。我们不能用ls命令见到IPC对象，不能用`rm`命令删除它们，也不能用`chmod`命令更改它们的访问权限。

因为这些IPC不使用文件描述符，所以**不能对它们使用多路转接I/O函数**：`select`和`poll`或者`epoll`。这就使得难于一次使用多个IPC结构，以及在文件或设备I/O中使用IPC结构。

##### 消息队列(MessageQueue)

消息队列是**消息的链接表**，存放在内核中并由消息队列标识符标识。这里，我们将称消息队列为“队列”，其标识符为“队列ID”。

整个消息队列有**两种**类型的数据结构：

1. `msqid_ds`消息队列数据结构：描述整个消息队列的属性，主要包括整个消息队列的权限，拥有者、两个重要的指针分别指向消息队列的第一个消息和最后一个消息。
2. `msg`消息数据结构：整个消息队列的主体，一个消息队列有若干个消息，每个消息数据结构的基本成员包括消息类型、消息大小、消息内容指针和下一个消息数据结构位置。

<img src="https://s1.ax1x.com/2020/08/09/a7DHN8.jpg" alt="消息队列" style="zoom: 67%;" />

整个消息队列的基本属性由`msqid_ds`数据结构在文件`/usr/include/msg.h`中定义：

```C
struct msqid_ds{
	struct ipc_perm msg_perm;		//权限
	struct msg *msg_first;			//指向消息头
	struct msg *msg_last;			//指向消息尾
	__kernel_tiem_t msg_stime;		//last msgsnd time 最近发送消息时间
	__kernel_tiem_t msg_rtime;		//lsat msgrcv time 最近接受消息时间
	__kernel_tiem_t msg_ctime;		//last change time
	unsigned long msg_lcbytes;		//Reuse junk fields for 32 bit
	unsigned long msg_lqbytes;		//ditto
	unsigned short msg_qnum;		//current number of bytes on queue 当前队列大小
	unsigned short msg_qbytes;		//max number of bytes on queue 队列最大值
	__kernel_ipc_pid_t msg_lspid;		//最近msgsnd 的pid
	__kernel_ipc_pid_t msg_lrpid;		//最近receive 的pid
};
```

`struct msg`消息结构体：

```c
struct msg_msg{
	struct list_head m_list;
	long m_type;		//消息类型
	int m_ts;		//消息大小
	struct msg_msgseg *next;//下一个消息位置
	void *security;		//the actual message follows immediately 真正消息位置
};
```

`msgget()`用于**创建**一个新队列或打开一个现存的队列。

`msgsnd()`用于将新消息**添加**到队列尾端。每个消息包含一个正长整型类型字段，一个非负长度以及实际数据字节（对应于长度），所有这些都在将消息添加到队列时，传送给`msgsnd()`。

`msgrcv()`用于从队列中**取**消息。我们并不一定要以先进先出次序取消息，也可以按消息的类型字段取消息。

#### 4、信号量(Semaphore)

信号量与之前所介绍的几种IPC机制有所不同，它更类似于一个**计数器**，用于多个进程间共享对象（临界区）的访问控制，使得资源在一个时刻只有一个进程独享。也许你会说为什么不用一个全局变量来作为计数器，很显然，不同的进程拥有各自的地址空间，如果一个进程的全局变量能够为其他进程所见，那么我们还研究什么IPC呢，这显然是十分不安全的。

为了获取某个被多个进程所共享的资源，进程需要进行以下操作：

1. 测试控制该资源的信号量。如果信号量的值为正(大于0)，则可以使用该资源。
2. 此时，进程会将该信号量的值减一，表明自己占用了一个资源单位。
3. 如果信号量的值为0，则进程进入休眠状态，直至该信号量的值大于0时，进程会被操作系统唤醒，进入步骤(1)，重新判断自己能否获取该共享资源。

很显然，对信号量进行加1或者减1时的操作应当是原子操作，因此，信号量通常是在**内核**当中实现的。

常用的信号量形式为`二元信号量`，它只控制一个单位资源，初始值为1，也就代表着同一时刻有且仅有一个进程可以获取到该共享资源，这也是用信号量实现的一种**互斥锁**。<!--当多个进程尝试获取同一个共享资源时，它们会依次进入休眠状态，那么操作系统在该资源被释放时，应当唤醒哪一个进程呢？是否会遵循先来后到的原则？这个问题有待进一步思考。-->

当我们想要使用一个XSI信号量时，我们需要使用函数`semget()`来获得一个信号量ID。它的函数原型如下所示：

```c
int semget(key_t ket, int nsems, int flag);
```

XSI信号量远比二元信号量要复杂的多，而造成这种复杂性的原因在于：

1. 信号量并非是单个负值，而必须定义为含有一个或多个信号量值的集合，当创建信号量是，要指定集合中信号量值的数量。
2. 信号量的创建是独立于它的初始化的，这是一个致命的缺点，因为不能原子的创建一个信号量的集合，并对该集合中的各个信号量值进行初始化。
3. 即使没有进程正在使用各种形式的XSI IPC，它们仍然是存在的，有的程序在终止时，并没有释放已经分配给他的信号量，所以我们不得不为这种进程担心。

#### 5、共享内存(SharedMemory)

共享内存允许两个或多个进程共享一个给定的内存区域，因为数据不需要在客户端和服务器之间进行复制，因此这是**最快的一种IPC**。在使用共享内存时，最为重要的一点就是，在多个进程之间同步访问一个给定内存区域时，因当使用一定**同步机制**来保证任意时刻只有一个进程能够访问该内存区域。

进程可以将**同一段物理内存**连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

在Linux中，每个进程都有属于自己的进程控制块（PCB）和地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的虚拟地址与物理地址进行映射，通过内存管理单元（MMU）进行管理。两个不同的虚拟地址通过页表映射到物理空间的同一区域，它们所指向的这块区域即共享内存。

<img src="https://s1.ax1x.com/2020/08/09/a7gsHA.png" alt="共享内存" style="zoom: 67%;" />

创建共享内存：

```C
int shmget(key_t key, size_t size, int shmflg);
```

挂接共享内存:

```C
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

去关联共享内存:

函数并不删除所指定的共享内存区，而是将之前用`shmat`函数连接好的共享内存区脱离目前的进程

```C
int shmdt(const void *shmaddr);
```

销毁共享内存:

```C
int shmctl(int shmid, int cmd, struct shmid_ds *buf);
```

#### 6、套接字(Socket)

所谓**套接字(Socket)**，就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。当然，这种机制也可以用于本地。

因此，套接字可以分为两种类型，其一是**网络套接字**，它给予了运行于不同主机之间的进程互相沟通的能力。网络套接字需要底层协议的支持，例如 TCP（传输控制协议）或 UDP（用户数据报协议）。其二是**Unix域套接字**，它给予了运行于同一主机上的不同进程之间的沟通能力。Unix域套接字依赖于本地系统内核的支持来进行通信，使用一个本地的文件路径作为套接字地址，而创建的socket文件也会真实的存在于文件系统之中，不过当Unix域套接字建立连接之后，该socket文件就无效了。

由于套接字是一个十分宏大的话题，在《Unix网络编程》一书中进行了十分详细的介绍。由于内容太过庞大，因此这里仅作简要介绍。

在定义套接字类型的时候，网络套接字通常使用**AF_INET**进行定义；Unix域套接字则使用**AF_UNIX**进行定义。

套接字类型有三种，分别是**流式套接字**、**数据报套接字**和**原始套接字**。

**流式套接字**(SOCK_STREAM)：流式套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流式套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即**TCP**协议。

**数据报套接字**(SOCK_DGRAM)：数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用**UDP**协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。当然，当使用Unix域套接字时，数据报通过内核进行传输，不会经过TCP/IP协议栈在网络当中进行传输，因此不会出现丢包的情况。

**原始套接字**(SOCK_RAW)：原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。

通常在本地的进程间通信时，使用的更多的时Unix域套接字，与之配套的还有一个**抽象命名空间**的概念。在使用抽象命名空间时，我们会将`sockaddr_un.sun_path`的第一个字符设置为'\0'，而命令路径从第二个字符开始，这样就可以创建一个抽象的socket文件，它不存在于文件系统当中，可以用于建立**AF_UNIX**的socket连接，在`bind`之前也无需进行`unlink`操作，断开连接页同样无需`unlink`，所以它是一个抽象的、不实际存在于文件系统当中的socket文件。

#### 7、信号(signal )

所谓的**信号**，可以认为是一种操作系统在软件层面上去**模拟硬件中断**的实现，它是一种**异步**通信的机制。信号可以直接在用户态的进程和内核态的进程之间进行交互，通常是内核进程用信号来通知用户态的进程发生了某些事件。如果该进程处于休眠状态，那么信号会被储存起来，直到该进程被调度程序唤醒，此时再将信号传递给该进程。

**SIGINT**：`ctrl+c` 终止信号

**SIGQUIT**：`ctrl+\` 终止信号

**SIGTSTP**:`ctrl+z` 暂停信号

**SIGALRM**：闹钟信号 收到此信号后定时结束，结束进程

**SIGCHLD**：子进程状态改变，父进程收到信号

**SIGKILL**：杀死信号

**SIGPIPE**：之前说过，当向一个读端已关闭的管道中写入数据时会产生

**SIGHUP**：终端关闭时、会话(session)首进程退出时会产生，以及父进程退出导致进程组成为孤儿进程组，且该进程组中有进程处于停止状态时，该信号会被发送到该进程组中的每一个进程。

**SIGURG**：内核通知进程`带外数据`到达。<!--带外数据用于迅速告知对方本端发生的重要的事件。它比普通的数据（带内数据）拥有更高的优先级，不论发送缓冲区中是否有排队等待发送的数据，它总是被立即发送。带外数据的传输可以使用一条独立的传输层连接，也可以映射到传输普通数据的连接中。实际应用中，带外数据是使用很少见，有，telnet和ftp等远程非活跃程序。-->

可以使用`kill()`函数发送指定信号给指定进程：

```C
int kill(pid_t pid, int sig);
```

```C
int raise(int sig); //用于进程向自己发送信号
unsigned int alarm(unsigned int seconds); //在进程中设置一个定时器
int pause(void);  //将进程挂起，直到收到信号为止
void (*signal(int signum, void (*handler)(int)))(int);//信号处理函数
void abort(void); //给自己发送异常终止信号，终止并产生core文件。
```

需要说明的是，`signal()`函数可以用来捕获任意的信号，例如kill产生的信号，或者终端关闭产生的SIGHUP信号，以保证程序的正常运行，不至于意外退出。它需要指定相应的信号以及信号处理函数。

参考文献：

[1] Unix环境高级编程

[2] 部分网络文章