---
title: 动态编译符号表冲突的解决方案
date: 2020-10-21 22:39
tags: [基础,杂项]
categories: 编程
toc: false
---

<img src="https://s1.ax1x.com/2020/10/21/BPcWQS.jpg" alt="动态编译符号表冲突的解决方案" style="zoom:40%;" />

近期在工作当中遇见了一个问题，记录一下分析和学习的过程。项目上近期提供了一个工具，需要我们调用这个工具的动态库中的部分函数来完成业务逻辑，其中一个函数A使用了某个系统提供的动态库，假设它调用了系统动态库中的函数B1。

偏偏很不凑巧的是，我们的版本之前也曾经将这个动态库用静态编译的方式集成进来，也就是说，我们的版本里也有一个与函数B1同名的函数，这里称之为B2吧。此时就导致了一个很诡异的现象——当我们使用动态链接的方式将版本编译出来，执行可执行文件，函数A没有去调用系统动态库中的函数B1，而是调用了版本当中的函数B2，这时就会产生段错误或者其他的一些意想不到的情况。

下面就来分析一下为什么会出现这样的情况。

<!--more-->

#### 1.静态编译与动态编译

首先，让我们先来弄明白什么是静态编译和动态编译。网上相关的介绍很多，这里就不再自己手码了，贴下网上的一些介绍：

>  **动态编译**：动态编译的可执行文件需要附带一个的动态链接库，在执行时，需要调用其对应动态链接库中的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的运行库，则用动态编译的可执行文件就不能运行。
>
> **静态编译**：静态编译就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应静态链接库(.a)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于静态链接库。所以其优缺点与动态编译的可执行文件正好互补。

直白的说，动态编译的可执行文件需要依赖动态库，执行的时候需要去动态库中去链接执行的代码片段。而静态编译则不需要，因为所有需要的代码已经被链接到可执行文件当中了。

#### 2.符号表

再谈一下符号表，可执行文件、动态库、静态库都具有符号表，可以通过nm命令查看。符号和符号表的主要作用就是让链接器在链接时能够定位到目标文件当中的某一段代码。链接器的输入是一组可重定位目标模块，每个模块当中都定义了一组符号，有些是局部的，即只对定义该符号的模块可见，有些是全局的，即对其他模块也是可见的。如果多个模块定义了同名的全局符号，就会发生之前我所提到的那种情况。

根据CSAPP中对Linux系统编译时动作的解释，我们可以知道，在编译时，编译器会向汇编器输出每个全局符号，可能是强符号也可能是弱符号，汇编器会把这个信息隐含地编码在可重定位目标文件的符号表中。其中，函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。

而对强弱符号，Linux的规则如下：

> 规则1：不允许有同名的强符号
>
> 规则2：如果有一个强符号和多个弱符号同名，取强符号
>
> 规则3：如果多个弱符号重名，随机选取一个

#### 3.问题分析及解决方案

如果将一个静态库链接到可执行文件当中，当我们尝试将动态库链接进来的时候，静态库中的函数优先级是高于动态库的(具体原因还不能很明确的给出来，仍待修炼……准备生啃程序员的自我修养)。这就导致我们明明想要执行的是动态库中的函数，结果执行的却是静态库中的函数。

这里暂时想到且能实现的方案有两个：

> 1、更换静态库/动态库的函数名称---从根源解决问题，但是有点蠢。
>
> 2、使用`dlopen()`指定使用动态库中的函数(有点繁琐，但是不必改名)。

第一个就不细说了，谁都会。主要说下第二个方法。`dlopen()`可以以指定模式打开指定的动态链接库文件，并返回一个句柄给`dlsym()`的调用进程，可以使用`dlclose()`来卸载打开的库。

以下示例：

先定义一个函数`Test_Fcn()`，这里就不用静态库了，直接在源文件中编码。

```C
#include <stdio.h>
int Test_Fcn();
int main()
{
    Test_Fcn();
    return 0;
}

int Test_Fcn(){
    printf("This function is in main.o!\n");
}
```

执行的话，毫无疑问，输出为：

```
This function is in main.o!
```

我们再编写一个`libtest.c`，动态编译为`libtest.so`。

```C
#include <stdio.h>
int Test_Fcn()
{
    printf("This function is in libtest.so!\n");
    return 0;
}
```

执行命令：`gcc -fPIC -shared libtest.c -o libtest.so`即可，此时再用动态链接的方式编译`main.c`。再次执行可执行文件，不出意料，结果仍然为：

```C
This function is in main.o!
```

显然，我们编写的动态库没有生效，执行`nm main |grep Test_Fcn`，可以得到`000000000040064b T Test_Fcn`，其中的`T`代表`Test_Fcn`函数位于可执行文件的代码区，也就是说已经被链接到可执行文件中来了，显然不是动态编译。

此时我们对`main.c`进行下修改，使用`dlopen()`来强制指定使用so中的函数。

```C
#include <stdio.h>
#include <dlfcn.h>
int Test_Fcn();
typedef int(*FCN)();
int main()
{
    void* handler=dlopen("./libtest.so",RTLD_LAZY);
    FCN Test_Fcn=dlsym(handler,"Test_Fcn");
    Test_Fcn();
    dlclose(handler);
    return 0;
}

int Test_Fcn(){
    printf("This function is in main.o!\n");
}
```

此时再次执行就可以发现，输出变为：

```C
This function is in libtest.so!
```

这里成功的调用了我们在动态库中编写的`Test_Fcn()`。通过`nm`指令可以发现`Test_Fcn`仍然在可执行文件的符号表当中。

在查阅资料的时候发现貌似还有别的方法可以将静态库中的符号变为局部可见的，使得符号表冲突的问题可以得到解决，需要在`gcc`编译静态库的时候加一些选项，这部分暂时还不太懂，仍然需要学习。

下一步的计划是先将CSAPP中有关链接的部分学习完毕，之后再学习以下《程序员的自我修养:链接、装载与库》，这些知识都是内功啊，任重而道远。

参考文献：

[1] 《深入理解计算机系统》

[2]《程序员的自我修养:链接、装载与库》

[3] [解决动态库的符号冲突](https://blog.csdn.net/weixin_44555968/article/details/90485329)