---
title: DFS和BFS学习记录
date: 2020-09-09 21:37
tags: [算法,数据结构]
categories: 编程
toc: false
---

<img src="https://s1.ax1x.com/2020/09/09/w8lXkR.jpg" alt="epoll" style="zoom:40%;" />

简要记录广度优先搜索(DFS)和深度优先搜索(BFS)两种搜索算法在遍历树型结构时的应用。附上Leetcode-559. N叉树的最大深度使用DFS和BFS的两种解法。test

<!--more-->

> 广度优先搜索是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和广度优先搜索类似的思想，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。
>
> ​																																			 																	-----以上来自百度百科

广度优先搜索(DFS)算法，根据名字即可猜出它的大致思想，即以广度为第一优先级，进行层层递进式的搜索。在图中，以一个节点为起始，依次访问它的所有邻居节点，之后再访问邻居的邻居，再以此类推，直到访问完所有节点为止。很显然，这样的搜索方式会存在一个问题，可能会再两个节点之间形成一个环，导致搜索路径陷入这个环中。因此，在图中的广度优先搜索需要记录每个节点是否被搜索过，保证每个节点只会被搜索一次。

实现DFS，需要使用一个队列存放等待搜索的节点，借助一个列表来记录每个节点是否被搜索过，借助一个散列表来记录每个节点对应的邻居。

如果是在树型结构中实现DFS，则无需考虑重复搜索的问题，也无需考虑邻居关系，因为树型结构即不会出现环，也无需刻意记录邻居关系。

>  深度优先搜索属于图算法的一种，其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

对于二叉树而言，深度优先搜索即我们熟悉的前序遍历、中序遍历、后序遍历。

深度优先搜索用栈来实现，整个过程可以想象成一个倒立的树形：

> 1. 把根节点压入栈中。
> 2. 每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。
> 3. 找到所要找的元素时结束程序。
> 4. 如果遍历整个树还没有找到，结束程序。


广度优先搜索使用队列来实现，整个过程也可以看做一个倒立的树形：
> 1. 把根节点放到队列的末尾。
> 2. 每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。
> 3. 找到所要找的元素时结束程序。
> 4. 如果遍历整个树还没有找到，结束程序。

结合Leetcode的一道题目来进行理解。

####  [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 `3叉树` :

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" alt="三叉树" style="zoom:50%;" />

我们应返回其最大深度，3。

**说明:**

1. 树的深度不会超过 `1000`。
2. 树的节点总不会超过 `5000`。

解法1：广度优先搜索

```C++
class Solution {
public:
    int maxDepth(Node* root) {
        //BFS广度优先搜索
        if (!root)
            return 0;
        queue<Node*> q;
        int depth=0;
        q.push(root);
        //把队列中的每个节点遍历一遍，并将其child加入队列尾部
        while(!q.empty())
        {
            depth++;
            for(int size=q.size();size;size--)//遍历第i层的所有节点
            {
                Node* cur=q.front();//指向当前节点，并让其出队列
                q.pop();
                for (int i=0;i<cur->children.size();i++)
                {
                    q.push(cur->children[i]);//将当前节点的所有child依次加入队列尾部
                }
            }
        }
        return depth;
    }
};
```

解法2：深度优先搜索

```C++
class Solution {
public:
    int maxDepth(Node* root) {
        //DFS深度优先搜索
        if(!root)
            return 0;
        stack<pair<Node*,int>> s;//pair<Node*,int>分别存放节点指针和它对应的深度
        s.push(pair<Node*,int>(root,1));//先存入根节点
        int maxdepth=0;//最大深度(由于深度优先搜索在进入最深节点后会回溯到父节点之上，去尝试寻找更深的节点，所以需要记录下最大深度)
        while(!s.empty())
        {
            Node* cur=s.top().first;//取出当前最前面的节点
            int depth=s.top().second;//记录当前深度
            s.pop();
            for(Node* it:cur->children)//将当前节点的所有孩子节点依次入栈，如果有孩子节点，会一直深入到叶子节点。
            //当所有孩子节点都被遍历完成后，回溯到父节点，继续遍历父节点的兄弟节点。
            {
                s.push(pair<Node*,int>(it,depth+1));//由于入栈的为孩子节点，所以深度加1
            }
            maxdepth=max(maxdepth,depth);//更新最大深度
        }
        return maxdepth;
    }
};
```

