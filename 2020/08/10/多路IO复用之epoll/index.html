<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,同步," />










<meta name="description" content="I&#x2F;O多路复用是通过一种机制，让进程可以同时监听多个文件描述符，当某个文件描述符符合某种状态时，能够通知到相应的进程采取对应的操作。多路复用机制发展至现在，常用的有select、poll、epoll三种方式，它们的发展历程是一个不断优化的过程。本文首先简要介绍多路复用机制的概念，再简单描述下它的发展例程，会着重介绍epoll的机制及部分实现。文中内容提炼了不少前人梳理的结果，并加以自己的理解进">
<meta property="og:type" content="article">
<meta property="og:title" content="I&#x2F;O多路复用之epoll">
<meta property="og:url" content="http://yoursite.com/2020/08/10/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/index.html">
<meta property="og:site_name" content="咸鱼小站">
<meta property="og:description" content="I&#x2F;O多路复用是通过一种机制，让进程可以同时监听多个文件描述符，当某个文件描述符符合某种状态时，能够通知到相应的进程采取对应的操作。多路复用机制发展至现在，常用的有select、poll、epoll三种方式，它们的发展历程是一个不断优化的过程。本文首先简要介绍多路复用机制的概念，再简单描述下它的发展例程，会着重介绍epoll的机制及部分实现。文中内容提炼了不少前人梳理的结果，并加以自己的理解进">
<meta property="og:image" content="https://s1.ax1x.com/2020/08/11/aq5Z0f.jpg">
<meta property="article:published_time" content="2020-08-10T15:45:00.000Z">
<meta property="article:modified_time" content="2020-09-03T16:53:02.541Z">
<meta property="article:author" content="HZhang">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="同步">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2020/08/11/aq5Z0f.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/08/10/多路IO复用之epoll/"/>





  <title>I/O多路复用之epoll | 咸鱼小站</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">咸鱼小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learning, and coding.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-program">
          <a href="/categories/program/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-other">
          <a href="/categories/other/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            其他
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/10/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咸鱼小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">I/O多路复用之epoll</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-10T23:45:00+08:00">
                2020-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/program/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/08/10/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/08/10/多路IO复用之epoll/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2020/08/10/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/" class="leancloud_visitors" data-flag-title="I/O多路复用之epoll">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <img src="https://s1.ax1x.com/2020/08/11/aq5Z0f.jpg" alt="epoll" style="zoom:40%;" />

<p>I/O多路复用是通过一种机制，让进程可以同时监听多个文件描述符，当某个文件描述符符合某种状态时，能够通知到相应的进程采取对应的操作。多路复用机制发展至现在，常用的有select、poll、epoll三种方式，它们的发展历程是一个不断优化的过程。本文首先简要介绍多路复用机制的概念，再简单描述下它的发展例程，会着重介绍epoll的机制及部分实现。文中内容提炼了不少前人梳理的结果，并加以自己的理解进行阐述。</p>
<a id="more"></a>

<h4 id="1、阻塞、非阻塞、同步、异步"><a href="#1、阻塞、非阻塞、同步、异步" class="headerlink" title="1、阻塞、非阻塞、同步、异步"></a>1、阻塞、非阻塞、同步、异步</h4><p>阻塞、非阻塞、同步、异步，这几个概念一开始就曾让我困惑了很久。阻塞和同步不是一个意思嘛？非阻塞不就是异步嘛？为啥还搞这些乱七八糟花里胡哨的。为了弄懂这些名词的区别，我开始在网上查阅资料，在知乎上看到一个解释，感觉十分清晰，这里分享一下。</p>
<p>同步与异步，关注的是消息通信的机制，<strong>重点在于通信机制的不同</strong>。</p>
<p>同步指的是，在消息交互的过程当中，我给你打了一个电话，在你给我回复之前，我要一直把电话开着，等你给我回复，直到你给我回消息之后，我才会挂断电话。用专业术语来说就是，<strong>在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</strong>结合例子，做出解释就是，在发出一个调用(我给你打电话)时，在没有得到结果(你给我回复我想要的消息)之前，该调用就不返回(我不会挂断电话)。但是一旦调用返回(我挂掉电话)，就得到返回值了(意味着我得到了我想要的消息)。</p>
<p>异步指的是，在消息交互的过程当中，我给你发一个信息，我就先去干别的事情了，等你给我回复信息之后，我再来看你回的消息。用专业术语来说就是，<strong>当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</strong>在结合例子解释一下，就是说，当一个异步过程调用(发信息)发出后，调用者(我)不会立刻得到结果。而是在调用发出后，被调用者(你)通过状态、通知(给我回消息)来通知调用者，或通过回调函数处理这个调用。</p>
<p>注意到了没有，区别在哪里，就是在于这个<strong>机制</strong>的不同，<strong>同步类比于电话，异步类比于短信</strong>，两种不同的消息通信机制。我给你打电话，如果你没给我回复时，我就挂了电话，那么我就无法获得想要的信息了。而我给你短信，在我发出去之后，我就可以不管了，等你给我回复了，我再过来看你回复的消息。</p>
<p>阻塞与非阻塞，关注的是在等待调用结果时的一个状态，<strong>重点是在等待期间的状态的不同</strong>。</p>
<p>阻塞指的是，当我在等你给我回复之前，我啥也不干，就在那干等着，直到你给我回复之后，我才去做别的事情。用专业术语来说就是，<strong>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。</strong></p>
<p>而非阻塞指的是，在我等你给我回复之前，我可以做一些别的事，不用在那里干等着。用专业术语来解释就是，<strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</strong></p>
<p>现在你来思考一下，能否区分出阻塞与同步，非阻塞与异步？</p>
<p>如果还有一点点晕，再仔细的阅读一下之前的同步与异步的例子，推敲一下阻塞与非阻塞的场景，与之有何不同。</p>
<p>好的，其实阻塞和同步之所以容易混淆，是因为他们似乎都是有一个<code>等待</code>的过程，不过之前在解释什么是同步的时候，已经指出了它的重点在于同步是一种消息通信的机制，它的重点在机制上。</p>
<p>什么样的场景是同步阻塞呢，比如我给你打电话，你没有给我回消息，我保持电话畅通，这时候来了个快递，我为了等你就没管，然后你给我回复了消息，我听到后就挂断了电话，再去签收了快递。</p>
<p>而同步非阻塞呢，同样类似上面的例子，我给你打电话，你没有给我回消息，我保持电话畅通，这时候来了个快递，我顺手就签收了，然后你给我回复了消息，我听到后就挂断了电话。</p>
<p>这样是不是就理解了何为阻塞，何为同步。<strong>阻塞是一种状态</strong>，当你阻塞时，你不可以干别的事，只能等，<strong>而同步是一种机制</strong>，当你使用了同步的机制的时候，你没有获取到结果时，你就要保持住，不能够返回。至于你在保持的期间，啥也不干，还是做些别的事，这不是同步机制所关心的。</p>
<p>异步其实类似，这里不再赘述。</p>
<p>最后用那个帖子里的一个回复来说明下问题吧，假设你要买一本书，现在你要问老板有没有，这时候你要去问下老板，于是乎，有了以下这几种情况：</p>
<blockquote>
<p> <strong>同步阻塞</strong>：你打电话问老板有没有某书，老板去查，在老板给你结果之前，你一直拿着电话等待老板给你结果，你此时什么也干不了。<br> <strong>同步非阻塞</strong>：你打电话过去后，在老板给你结果之前，你拿着电话等待老板给你结果，但是你拿着电话等的时候可以干一些其他事，比如嗑瓜子。<br> <strong>异步阻塞</strong>：你打电话过去后，老板去查，你挂掉电话，等待老板给你打电话通知你，这是异步，你挂了电话后还是啥也干不了，只能一直等着老板给你打电话告诉你结果，这是阻塞。<br> <strong>异步非阻塞</strong>：你打电话过去后，你就挂了电话，然后你就想干嘛干嘛去。只用时不时去看看老板给你打电话没。</p>
</blockquote>
<h4 id="2、IO模型"><a href="#2、IO模型" class="headerlink" title="2、IO模型"></a>2、IO模型</h4><p>聊完前面的几个概念之后，我们再来看IO模型的时候理解起来就比较轻松了。常见的几种IO模型有：</p>
<blockquote>
<p> 传统IO——同步阻塞IO</p>
<p> NONBLOCK的socket——同步非阻塞IO</p>
<p> IO多路复用(Reactor设计模式)——异步阻塞IO</p>
<p> Proactor设计模式——异步非阻塞IO</p>
</blockquote>
<p>我们这里讨论的就是IO多路复用，也就是epoll，当然还包括select和poll这两个前辈，这三个IO多路复用机制都是属于异步阻塞IO。</p>
<h5 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h5><p>首先，让我们从最原始的IO模型说起，也就是<code>read()</code>。read的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure>

<p>read函数向操作系统发起一个IO申请，申请从指定的文件描述符fd中读取数据，存放至buf缓冲区当中，每次最多读取count个字节。read这个函数在文件操作和socket编程中常常会使用到。</p>
<p>例如在socket通信中，如果我们使用默认的socket，那么在发起read请求之后，在尚未有数据通过网络传输至网口上时，进程会一直阻塞。假设此时有数据通过网络传输至网口上时，网口会产生硬件中断，通知CPU有数据到达，此时CPU会进行上下文切换，陷入网卡的中断处理程序当中，将网卡内的数据读取至内存当中。将数据拷贝至内存中后，CPU退出中断处理程序，告诉read函数socket的输出缓冲区中已经有数据了，此时read将数据从内核中拷贝至进程的地址空间(buf缓冲区)当中，并返回读取到的字节数。这就是一次read的全部流程。</p>
<p><code>read()</code>是最为简单的一种IO模型，使用起来很简单，但是问题也很明显，那就是他一次只能监听一个文件描述符，如果我要监听多个文件描述符，那么我就得创建多个线程去分别监听不同的文件描述符，这无疑是一件十分浪费资源的事。</p>
<h5 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h5><p>因此，<code>select()</code>出现了。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, </span></span></span><br><span class="line"><span class="function"><span class="params">           fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>select()</code>函数相比于<code>read()</code>或者<code>recv()</code>这种IO最大的优点就是，它允许进程监视多个文件描述符！</p>
<p>当调用select()函数后，进程会进入阻塞状态，等待所监视的一个或者多个文件描述符变为ready状态。所谓的ready状态是指：文件描述符不再是阻塞状态，可以用于某类IO操作了，包括<strong>可读</strong>、<strong>可写</strong>、<strong>发生异常</strong>三种。</p>
<p>nfds表示操作系统需要监听的文件描述符个数，这里实际上它的值应该为你所需要监听的最大的文件描述符+1，也就是说实际上操作系统监听了0~max_fd+1之间的所有文件描述符。select采用的是轮询机制，它会一直去检测fd_set中被监视的文件描述符是否有变为ready状态的，当其中的一个或者多个变为ready状态后，select函数会返回ready状态的文件描述符的个数。</p>
<p><code>select()</code>解决了read和recv一次只能监听一个文件描述的问题，但是单个进程所能监听的文件描述符是有限的，并且采用了轮询机制，时间复杂度为O(n)，当文件描述符越多的时候，它的性能也就越差，并且会频繁的产生内核态与用户态之间的切换。</p>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h5><p><code>poll()</code>其实与<code>select()</code>没有太大的区别，它的原型如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int poll(struct pollfd fds[], nfds_t nfds, int timeout)；</span><br></pre></td></tr></table></figure>

<p>poll和select实现功能差不多，但poll效率高，它通过一个结构体数组存放需要检测其状态的Socket描述符；每当调用这个函数之后，系统不会清空这个数组，操作起来比较方便；特别是对于socket连接比较多的情况下，在一定程度上可以提高处理的效率；这一点与select()函数不同，调用select()函数之后，select()函数会清空它所检测的socket描述符集合，导致每次调用select()之前都必须把socket描述符重新加入到待检测的集合中；因此，select()函数适合于只检测一个socket描述符的情况，而poll()函数适合于大量socket描述符的情况。</p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll()"></a>epoll()</h5><p>鉴于<code>poll()</code>和<code>select()</code>存在的诸多问题，Linux为处理大批量文件描述符，对<code>poll()</code>进行改进后用<code>epoll()</code>取而代之。<code>epoll()</code>对于文件描述符的处理方式与前两个策略有所不同： <code>select()</code>在底层是用的数组去存储文件描述符，<code>poll()</code>则是用链表来存储，而epoll选择了用<strong>红黑树</strong>来存储文件描述符。</p>
<p>epoll()的三个主要函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建一个epoll文件描述符--epfd，其中size目前无实际意义，取址大于0即可*/</span></span><br><span class="line">int epoll_create(int size) ； </span><br><span class="line"><span class="comment">/* epfd的控制函数，用于增加/删除epoll句柄上监听的文件描述符，或者修改其模式。</span></span><br><span class="line"><span class="comment">op为epoll_ctl的动作，有三种：EPOLL_CTL_ADD、 EPOLL_CTL_MOD、EPOLL_CTL_DEL。</span></span><br><span class="line"><span class="comment">fd为被增加/删除/修改的文件描述符</span></span><br><span class="line"><span class="comment">event为描述需要监听事件的结构体。*/</span>    </span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) ； </span><br><span class="line"><span class="comment">/*等待epfd上所有监听的文件描述符，直到有事件触发或timeout超时，timeout=0立即返回，timeout=-1阻塞*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>epoll使用红黑树去<strong>监听</strong>并<strong>维护</strong>所有文件描述符，在调用<code>epoll_create()</code>时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后<code>epoll_ctl()</code>传来的socket外，<strong>还会再建立一个list链表，用于存储准备就绪的事件。</strong>当调用<code>epoll_wait()</code>时，仅仅观察这个链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后，即使链表没数据也返回。所以，<code>epoll_wait()</code>非常高效。</p>
<p>当我们执行<code>epoll_ctl()</code>添加文件描述符时时，除了把fd放到epoll在文件系统里的对象上对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，这个回调函数的功能是告诉内核，如果这个文件描述符的中断到了，就把它放到准备就绪链表里。所以，epoll()可以从就绪链表中，只对活跃或者说就绪状态的文件描述符调用回调函数，这可以显著的提升它的效率。因此，epoll()返回就绪的文件描述符的时间复杂度为O(1)。当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后，就把对应socket的fd插入到准备就绪链表里了。通常情况下即使我们要监控数以百万计的文件描述符，一次也只返回很少量“就绪”的文件描述符而已，因此，<code>epoll_wait()</code>仅需要从内核态拷贝少量的文件描述符到用户态，这是它相比于其他IO多路复用机制的一个显著优点。</p>
<p><code>epoll()</code>对于打开的文件描述符没有限制，一般是基于系统内存，而这个数字一般远大于1024。</p>
<p>然而，epoll相比于select并不是在所有情况下都要高效，例如在如果有少于1024个文件描述符监听，且大多数socket都是出于活跃繁忙的状态，这种情况下，select要比epoll更为高效，因为epoll会有更多次的系统调用，用户态和内核态会有更加频繁的切换。</p>
<p>最后说下<code>epoll()</code>的2种工作方式：LT和ET。</p>
<ol>
<li>LT(level triggered)，也就是水平触发，是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</li>
<li>ET (edge-triggered)，也就是边缘触发，是高速工作方式，只支持non-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过<code>epoll()</code>告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作，内核不会发送更多的通知，也就是说，内核只会通知你一次。ET和LT的区别就在这里体现，LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断的通知你。而ET则只在事件发生之时通知。</li>
</ol>
<p>总结，<code>epoll()</code>高效的本质在于：</p>
<blockquote>
<p>减少了用户态和内核态的文件句柄拷贝</p>
<p>减少了对可读可写文件句柄的遍历</p>
<p>mmap 加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝</p>
<p>IO性能不会随着监听的文件描述的数量增长而下降</p>
<p>使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间</p>
</blockquote>
<h4 id="3、epoll例程解析"><a href="#3、epoll例程解析" class="headerlink" title="3、epoll例程解析"></a>3、epoll例程解析</h4><p>以epoll三个基本函数实现了一个回声服务端+客户端的小例程。</p>
<p>功能是将客户端输入的字符转换为大写后返回。可以设置最大连接数量，超出的连接被丢弃。代码比较简陋，待完善。</p>
<p>代码放在码云上了，链接：<a href="https://gitee.com/zhanghh0624/myepolldemo" target="_blank" rel="noopener">myepolldemo</a></p>
<p><strong>1.ep.h  头文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;error.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; /* 定义数据结构sockaddr_in */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;  /* 提供IP地址转换函数 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EP_TABLE_MAX_NUM  20   <span class="comment">/* epoll最大处理 fd 数量 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_CONNECT_NUM   2  <span class="comment">/* 客户端最大连接数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1000          <span class="comment">/* recv/send buf大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SER_PORT 11111         <span class="comment">/* 服务端监听端口 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_PORT 12111         <span class="comment">/* 客户端绑定起始端口 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THROW_ERR  strerror(errno)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SER_IP <span class="meta-string">"192.168.1.6"</span> <span class="comment">/* 服务端ip */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLI_IP <span class="meta-string">"192.168.1.6"</span> <span class="comment">/* 客户端ip */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* LOG，调试用函数，直接打印输出*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_STDOUT(format, ...)      \  </span></span><br><span class="line">    <span class="keyword">do</span>                               \</span><br><span class="line">    &#123;                                \</span><br><span class="line">        <span class="built_in">printf</span>(format, ##__VA_ARGS__); \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2.ep.c   服务端部分</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../lib/ep.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ep_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cli_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cli_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> CLI_NUM = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>, <span class="title">cli_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    ep_fd = epoll_create(<span class="number">1</span>); <span class="comment">/* 创建epoll的文件描述符 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ser_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    set_noblocking(ser_fd); <span class="comment">/* epoll监听的文件描述符需要设置为非阻塞模式 */</span></span><br><span class="line"></span><br><span class="line">    bzero((<span class="keyword">void</span> *)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    bzero((<span class="keyword">void</span> *)&amp;cli_addr, <span class="keyword">sizeof</span>(cli_addr));</span><br><span class="line">    ser_addr.sin_family = AF_INET; <span class="comment">/* sin_port和sin_addr都必须是网络字节序（NBO），一般可视化的数字都是主机字节序（HBO） */</span></span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(SER_IP);</span><br><span class="line">    ser_addr.sin_port = htons(SER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = bind(ser_fd, (struct sockaddr *)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_STDOUT(<span class="string">"bind failed!%s\n"</span>, THROW_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(ser_fd, <span class="number">100</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_STDOUT(<span class="string">"listen failed!%s\n"</span>, THROW_ERR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ep_ev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ep_table</span>[<span class="title">EP_TABLE_MAX_NUM</span>];</span> <span class="comment">/* epoll_wait返回的描述符存放在这个结构体数组中 */</span></span><br><span class="line">    ep_ev.data.fd = ser_fd;                        <span class="comment">/* 监听的文件描述符为ser_fd */</span></span><br><span class="line">    ep_ev.events = EPOLLIN;                        <span class="comment">/* 监听ser_fd的输入事件，即连接请求 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(ep_fd, EPOLL_CTL_ADD, ser_fd, &amp;ep_ev) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_STDOUT(<span class="string">"ep_ctl failed!\n"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(ep_fd, ep_table, EP_TABLE_MAX_NUM, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nfds &lt;= <span class="number">0</span>) <span class="comment">/* 无描述符触发事件 */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nfds; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ep_table[i].data.fd == ser_fd) <span class="comment">/* 有连接请求接入 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    CLI_NUM++; <span class="comment">/* 接入计数+1 */</span></span><br><span class="line">                    cli_fd = accept(ser_fd, (struct sockaddr *)&amp;cli_addr, &amp;cli_len);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (CLI_NUM &lt;= CLI_CONNECT_NUM) <span class="comment">/* 小于组大连接数 */</span></span><br><span class="line">                        LOG_STDOUT(<span class="string">"recv connect from ip:%s,port:%d,client num:%d\n"</span>, inet_ntoa(cli_addr.sin_addr), ntohs(cli_addr.sin_port), CLI_NUM);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        LOG_STDOUT(<span class="string">"Too much connect...\n"</span>);</span><br><span class="line">                        <span class="built_in">close</span>(cli_fd);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* 将接入的用户加入epoll的监听队列 */</span></span><br><span class="line">                    set_noblocking(cli_fd);</span><br><span class="line">                    ep_ev.data.fd = cli_fd;</span><br><span class="line">                    ep_ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    <span class="keyword">if</span> (epoll_ctl(ep_fd, EPOLL_CTL_ADD, cli_fd, &amp;ep_ev) &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">"epoll ctl:"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 有客户端写入数据 */</span></span><br><span class="line">                <span class="keyword">if</span> (handle(cli_fd) &lt; <span class="number">0</span>)</span><br><span class="line">                    perror(<span class="string">"handle:"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">close</span>:</span><br><span class="line">    <span class="built_in">close</span>(ep_fd);</span><br><span class="line"></span><br><span class="line">    LOG_STDOUT(<span class="string">"Server is closing......\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set_noblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK)) &lt; <span class="number">0</span>)</span><br><span class="line">        perror(<span class="string">"set fd noblock:"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 处理用户数据，转换为大写，并返回总长度。 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> send_buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (recv(fd, recv_buf, BUF_SIZE, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG_STDOUT(<span class="string">"%s"</span>, recv_buf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; recv_buf[i] != <span class="string">'\n'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        recv_buf[i] = <span class="built_in">toupper</span>(recv_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = send(fd, recv_buf, BUF_SIZE, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.client.c     客户端部分</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../lib/ep.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>, <span class="title">cli_addr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ser_len, cli_len;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> recv_buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> send_buf[BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    bzero((<span class="keyword">void</span> *)&amp;ser_addr, <span class="keyword">sizeof</span>(ser_addr));</span><br><span class="line">    bzero((<span class="keyword">void</span> *)&amp;cli_addr, <span class="keyword">sizeof</span>(cli_addr));</span><br><span class="line"></span><br><span class="line">    cli_addr.sin_family = AF_INET;</span><br><span class="line">    cli_addr.sin_addr.s_addr = inet_addr(CLI_IP);</span><br><span class="line">    cli_addr.sin_port = htons(CLI_PORT);</span><br><span class="line"></span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_addr.s_addr = inet_addr(SER_IP);</span><br><span class="line">    ser_addr.sin_port = htons(SER_PORT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cli_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    bind(cli_fd, (struct sockaddr *)&amp;cli_addr, <span class="keyword">sizeof</span>(cli_addr));</span><br><span class="line">    <span class="keyword">if</span> ((ret = <span class="built_in">connect</span>(cli_fd, (struct sockaddr *)&amp;ser_addr, <span class="keyword">sizeof</span>(cli_addr))) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG_STDOUT(<span class="string">"Connect error!%s\n"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(send_buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">        <span class="built_in">memset</span>(recv_buf, <span class="number">0</span>, BUF_SIZE);</span><br><span class="line">        <span class="keyword">if</span> (fgets(send_buf, BUF_SIZE, <span class="built_in">stdin</span>) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        send(cli_fd, send_buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        recv(cli_fd, recv_buf, BUF_SIZE, <span class="number">0</span>);</span><br><span class="line">        LOG_STDOUT(<span class="string">"%s"</span>, recv_buf);</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cli_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有不完善的地方会定期更新。</p>
<p>以上。</p>
<p>参考文章：</p>
<p>[1] <a href="https://zhuanlan.zhihu.com/p/93609693" target="_blank" rel="noopener">深入理解Epoll</a></p>
<p>[2] <a href="https://www.jianshu.com/p/397449cadc9a" target="_blank" rel="noopener">IO多路复用的三种机制Select，Poll，Epoll</a></p>
<p>[3] <a href="https://www.cnblogs.com/yanguhung/p/10145755.html" target="_blank" rel="noopener">IO多路复用机制详解</a></p>
<p>[4] <a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/os/" rel="tag"># 操作系统</a>
          
            <a href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag"># 同步</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/27/UNIX%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1(IPC)/" rel="next" title="UNIX进程间通信(IPC)">
                <i class="fa fa-chevron-left"></i> UNIX进程间通信(IPC)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/25/LAN%E3%80%81WLAN%E3%80%81WAN%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="prev" title="LAN、WLAN、WAN的区别">
                LAN、WLAN、WAN的区别 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/me.jpg"
                alt="HZhang" />
            
              <p class="site-author-name" itemprop="name">HZhang</p>
              <p class="site-description motion-element" itemprop="description">╮(￣▽ ￣)╭	</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、阻塞、非阻塞、同步、异步"><span class="nav-number">1.</span> <span class="nav-text">1、阻塞、非阻塞、同步、异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、IO模型"><span class="nav-number">2.</span> <span class="nav-text">2、IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#read"><span class="nav-number">2.1.</span> <span class="nav-text">read()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">2.2.</span> <span class="nav-text">select()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">2.3.</span> <span class="nav-text">poll()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">2.4.</span> <span class="nav-text">epoll()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、epoll例程解析"><span class="nav-number">3.</span> <span class="nav-text">3、epoll例程解析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HZhang</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">总字数&#58;</span>
    
    <span title="总字数">26.7k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2020/08/10/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E4%B9%8Bepoll/';
          this.page.identifier = '2020/08/10/多路IO复用之epoll/';
          this.page.title = 'I/O多路复用之epoll';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("aIJmeck02DIo0AzpFF9lzwcY-gzGzoHsz", "1rGGAGoFh7EEihUVQU6YQUVl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
